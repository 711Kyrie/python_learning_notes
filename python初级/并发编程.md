**多任务的优势**

多个任务同时执行能够充分利用CPU资源，大大提高程序执行效率。

**思考一下：** 利用现学知识能够让多个任务同时执行吗？

不能，因为之前所写的程序都是单任务的，也就是说一个函数或者方法执行完成，另外一个函数或者方法才能执行。要想实现多个任务同时执行就需要使用多任务。



**多任务的概念**

- **概念**：多任务是指在**同一时间内执行多个任务**（给我们的感觉）。
  例如：现在电脑安装的操作系统都是多任务操作系统，可以同时运行着多个软件。

**多任务的两种表现形式**

- **并发**：在一段时间内，**交替执行任务**
- **并行**：在一段时间内，真正的**同时一起执行多个任务**

| 方面         | 并发 (Concurrency)     | 并行 (Parallelism) |
| :----------- | :--------------------- | :----------------- |
| **核心数量** | 单核即可               | 需要多核           |
| **执行方式** | 任务间快速切换         | 真正同时执行       |
| **适合场景** | I/O密集型任务          | CPU密集型任务      |
| **比喻**     | 一个服务员接待多桌客人 | 多个服务员同时工作 |
| **目标**     | 提高资源利用率         | 提高执行速度       |



进程 = CPU分配资源的最小单位。

线程 = CPU调度资源的基本单位。



## 多进程

**多进程作用**

多进程是Python程序中实现多任务的一种方式，使用多进程可以大大提高程序执行效率

**Python中多进程的基本工作方式**

程序运行起来，形成主进程，在主进程上创建子进程

**multiprocessing模块介绍**

- python中的多线程无法利用多核优势，如果想要充分地使用多核CPU的资源（os.cpu_count()查看），在python中大部分情况需要使用多进程。
  - Python提供了multiprocessing。
  - multiprocessing模块用来开启子进程，并在子进程中执行我们定制的任务（比如函数），该模块与多线程模块threading的编程接口类似。

**Process类的介绍**

**参数介绍**

- group参数未使用，值始终为None
- target表示调用对象，即子进程要执行的任务
- args表示调用对象的位置参数元组，args=(1,2,'ly',)
- kwargs表示调用对象的字典,kwargs=
- name为子进程的名称

**注意：在windows中Process()必须放到 `if __name == 'main__':`下**



**进程编号的作用**

进程编号唯一标识一个进程，方便管理进程。

在一个操作系统中，一个进程拥有的进程号是唯一的，进程号可以反复使用。
获取进程编号的目的是验证主进程和子进程的关系，可以得知子进程是由那个主进程创建出来的。

获取进程编号的两种操作  

- 获取当前进程编号  
- 获取当前父进程编号

 **查看当前进程的进程号`os.getpid()` 方法**

```python
from multiprocessing import Process
import os
import time


def task():
    # 查看当前进程的 进程（PID） 号
    print(f'当前程序:>>>>{os.getpid()} 正在运行')
    time.sleep(2)


if __name__ == '__main__':
    p = Process(target=task)
    p.start()

    print(f'这是主程序:>>>{os.getpid()}')

    # 这是主程序:>>>9928
    # 当前程序:>>>>3912 正在运行
```
**查看当前进程的进程号current_process().pid 方法**
```python
from multiprocessing import Process, current_process
import time


def task():
    # 查看当前进程的 进程（PID） 号
    print(f'当前程序:>>>>{current_process().pid} 正在运行')
    time.sleep(2)


if __name__ == '__main__':
    p = Process(target=task)
    p.start()

    print(f'这是主程序:>>>{current_process().pid}')

    # 这是主程序:>>>11168
    # 当前程序:>>>>10944 正在运行
``` 
查看当前进程的父进程的进程号os.getppid() 方法
```python
from multiprocessing import Process
import os
import time


def task():
    # 查看当前进程的 进程（PID） 号
    print(f'当前程序:>>>>{os.getpid()} 正在运行')
    # 查看当前进程的 父进程（PID） 号
    print(f'当前程序的父进程:>>>>{os.getppid()} 正在运行')
    time.sleep(2)


if __name__ == '__main__':
    p = Process(target=task)
    p.start()

    print(f'这是主程序:>>>{os.getpid()}')
    print(f'这是主程序的父进程:>>>{os.getppid()}')

    # 这是主程序:>>>22236
    # 这是主程序的父进程:>>>17720
    # 当前程序:>>>>3756 正在运行
    # 当前程序的父进程:>>>>22236 正在运行
```
进程的注意点

**不共享数据、主进程等待子进程结束**

## 多线程
线程依附于进程执行，是CPU调度的基本单元。

线程注意点：
线程之间执行是无序的
主线程会等待所有的子线程执行结束再结束
线程之间共享全局变量
线程之间共享全局变量数据出现错误问题，可以使用互斥锁解决

线程之间共享全局变量数据出现错误问题，为什么会出现这个问题
产生原因：
线程1还没有来得及执行完（一个完整的动作）前，被线程2抢走了资源，就可能出问题。

全局变量数据错误的解决办法：

线程同步：保证同一时刻只能有一个线程去操作全局变量。
同步：就是协同步调，按预定的先后次序进行运行。如：你说完，我再说，好比现实生活中的对讲机。

线程同步的方式：锁

## 互斥锁

注意：互斥锁是**多个线程一起去抢**，抢到锁的线程先执行，没有抢到锁的线程进行等待，等锁使用完释放后，其它等待的线程再去抢这个锁。

互斥锁的使用流程

1. 互斥锁的创建
   mutex = threading.Lock()

2. 上锁
   mutex.acquire()

3. 释放锁
   mutex.release()

**死锁**

一直等待对方释放锁的情景就是死锁。

死锁的原因：
使用互斥锁的时候需要注意死锁的问题，
未在合适的地方注意释放锁

死锁的结果：
会造成应用程序的停止响应，
应用程序无法再继续往下执行了

**优缺点对比**

进程优缺点：
- 优点：可以用多核
- 缺点：资源开销大

线程优缺点：
- 优点：资源开销小
- 缺点：不能使用多核